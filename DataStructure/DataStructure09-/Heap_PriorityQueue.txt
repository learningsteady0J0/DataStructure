★우선순위 큐

	들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나오는 자료구조.

★구현 방법
	1.배열 기반
		-우선순위대로 배열에 저장하면 끝.
		-데이터를 삽입 및 삭제하는 과정에서 데이터를 한 칸씩 뒤로 밀거나 한 칸씩 앞으로 당기는 연산필요.
		-삽입의 위치를 찾기 위해서 배열에 저장된 모든 데이터와 우선순위 비교연산을 해야할 수 도 있음.
	2.연결 리스트 기반
		-우선순위대로 노드를  저장하면 끝.
		-삽입의 위치를 찾기 위해서 배열에 저장된 모든 데이터와 우선순위 비교연산을 해야할 수 도 있음.
	3.힙을 이용

★힙 - (heap = 무엇인가를 차곡차곡 쌓아 올린 더미)
	 '완전 이진 트리'이고 모든 노드에 저장된 값은 자식 노드에 저장된 값보다 크거나 같아야 한다. 
	 즉 루트 노드에 저장된 값이 가장 커야한다.  (우선순위 큐의 규현을 위한 힙이기 떄문에 값 = 우선순위)

	최대 힙 - 루트 노드로 올라갈수록 저장된 값이 커지는 완전이진트리
	최소 힙 - 루트 노드로 올라갈수록 저장된 값이 작아지는 완전이진트리

	저장 과정 - 새로운 데이터는 '마지막 위치'에 저장. -> 부모 노드와 우선순위 비교를 하면서 
			    이동 제대로 된 위치를 찾을때까지 반복

	삭제 과정 - 결국 루트노드를 어떻게 채울 것인가가 메인 과제. -> '마지막 위치'에 있는 노드를 루트노드로 
				옮기고 자식노드와 비교하면서 제대로 된 위치를 찾음.

	성능
				데이터 저장 시간 복잡도     데이터 삭제 시간 복잡도
	배열 기반			O(n)						O(1)
	연결 리스트 기반		O(n)						O(1)
	힙 기반				O(logn/2)					O(logn/2)  -> 레벨이 하나 증가함에따라 연산횟수가 1증가함. 
																  즉 n의값이 2배씩오를때 마다 연산횟수 증가.

★힙의 구현
	리스트? 배열? -> 배열!  연결 리스트를 기반으로 힙을 구현하면, 새로운 노드를 '마지막 위치'에 추가하는 것이 쉽지 않음.
	
	왼쪽 자식 노드의 인덱스 값 = 부모 노드의 인덱스 값 x 2
	오른쪽 자식 노드의 인덱스 값 = 부모 노드의 인덱스 값 x 2 + 1
	부모 노드의 인덱스 값 = 자식 노드의 인덱스 값 / 2

★우선순위 큐 ADT

void PQueueInit(PQueue * ppq, PriorityComp pc);
-우선순위 큐의 초기화를 진행한다.
-우선순위 큐 생성 후 제일 먼저 호출되어야 하는 함수이다.

int PQIsEmpty(PQueue * ppq);
-우선순위 큐가 빈 경우 TRUE(1)을, 그렇지 않은 경우 FALSE(0)을 반환한다.

void PEnqueue(PQueue * ppq, PQData data);
-우선순위 큐에 데이터를 저장한다. 매개변수 data로 전달된 값을 저장한다.

PQData PDequeue(PQueue * ppq);
-우선순위가 가장 높은 데이터를 삭제한다.
-삭제된 데이터는 반환된다.
-본 함수의 호출을 위해서는 데이터가 하나 이상 존재함이 보장되어야 한다.